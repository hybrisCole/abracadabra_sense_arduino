<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>IMU Data Cropper</title>
    <!-- Add Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Add Chart.js v3.9.1 -->
    <script src="https://cdn.jsdelivr.net/npm/chart.js@3.9.1/dist/chart.min.js"></script>
    <!-- Add noUiSlider -->
    <link href="https://cdnjs.cloudflare.com/ajax/libs/noUiSlider/15.7.1/nouislider.min.css" rel="stylesheet">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/noUiSlider/15.7.1/nouislider.min.js"></script>
    <script>
        tailwind.config = {
            darkMode: 'class', // or 'media'
            theme: {
                extend: {
                    colors: {
                        border: "hsl(var(--border))",
                        input: "hsl(var(--input))",
                        ring: "hsl(var(--ring))",
                        background: "hsl(var(--background))",
                        foreground: "hsl(var(--foreground))",
                        primary: {
                            DEFAULT: "hsl(var(--primary))",
                            foreground: "hsl(var(--primary-foreground))",
                        },
                        secondary: {
                            DEFAULT: "hsl(var(--secondary))",
                            foreground: "hsl(var(--secondary-foreground))",
                        },
                        destructive: {
                            DEFAULT: "hsl(var(--destructive))",
                            foreground: "hsl(var(--destructive-foreground))",
                        },
                        muted: {
                            DEFAULT: "hsl(var(--muted))",
                            foreground: "hsl(var(--muted-foreground))",
                        },
                        accent: {
                            DEFAULT: "hsl(var(--accent))",
                            foreground: "hsl(var(--accent-foreground))",
                        },
                        card: {
                            DEFAULT: "hsl(var(--card))",
                            foreground: "hsl(var(--card-foreground))",
                        },
                    },
                    borderRadius: {
                        lg: "var(--radius)",
                        md: "calc(var(--radius) - 2px)",
                        sm: "calc(var(--radius) - 4px)",
                    },
                }
            }
        }
    </script>
    <style>
        :root {
            --background: 0 0% 100%;
            --foreground: 222.2 84% 4.9%;
            --card: 0 0% 100%;
            --card-foreground: 222.2 84% 4.9%;
            --primary: 221.2 83.2% 53.3%;
            --primary-foreground: 210 40% 98%;
            --secondary: 210 40% 96.1%;
            --secondary-foreground: 222.2 47.4% 11.2%;
            --muted: 210 40% 96.1%;
            --muted-foreground: 215.4 16.3% 46.9%;
            --border: 214.3 31.8% 91.4%;
            --input: 214.3 31.8% 91.4%;
            --ring: 221.2 83.2% 53.3%;
            --radius: 0.5rem;
        }

        .dark {
            --background: 222.2 84% 4.9%;
            --foreground: 210 40% 98%;
            --card: 222.2 84% 4.9%;
            --card-foreground: 210 40% 98%;
            --primary: 217.2 91.2% 59.8%;
            --primary-foreground: 222.2 47.4% 11.2%;
            --secondary: 217.2 32.6% 17.5%;
            --secondary-foreground: 210 40% 98%;
            --muted: 217.2 32.6% 17.5%;
            --muted-foreground: 215 20.2% 65.1%;
            --border: 217.2 32.6% 17.5%;
            --input: 217.2 32.6% 17.5%;
            --ring: 224.3 76.3% 48%;
        }
        #imuChart {
            max-height: 400px;
        }
    </style>
</head>
<body class="bg-background text-foreground dark">
    <div class="max-w-4xl mx-auto px-4 py-8">
        <h1 class="text-3xl font-bold text-center mb-8">IMU Data Cropper</h1>

        <div class="bg-card rounded-lg shadow-md p-6 mb-6 border border-border">
            <h2 class="text-xl font-semibold mb-4">1. Load CSV Data</h2>
            <input type="file" id="csvFile" accept=".csv" class="w-full p-2 border border-input rounded-md bg-background text-foreground focus:ring-2 focus:ring-ring focus:outline-none">
            <p class="text-xs text-muted-foreground mt-1">Select the IMU data CSV file.</p>
        </div>

        <div class="bg-card rounded-lg shadow-md p-6 mb-6 border border-border">
            <h2 class="text-xl font-semibold mb-4">2. Data Visualization &amp; Selection</h2>
            <p class="text-sm text-muted-foreground mb-2">Graph will appear here after loading data. Click on the graph to select start time.</p>
            <canvas id="imuChart"></canvas>
            <!-- Slider placeholder -->
            <!-- Read-only displays for selection -->
            <div class="grid grid-cols-1 md:grid-cols-2 gap-4 mt-4">
                <div>
                    <label for="startTime" class="block text-sm font-medium text-foreground">Start Time (ms):</label>
                    <input type="number" id="startTime" value="0" step="10" class="mt-1 block w-full p-2 border border-input rounded-md bg-background focus:ring-2 focus:ring-ring focus:outline-none">
                </div>
                <div>
                    <label for="chunkDuration" class="block text-sm font-medium text-foreground">Chunk Duration (ms):</label>
                    <input type="number" id="chunkDuration" value="500" step="10" class="mt-1 block w-full p-2 border border-input rounded-md bg-background focus:ring-2 focus:ring-ring focus:outline-none">
                </div>
            </div>
        </div>

        <div class="bg-card rounded-lg shadow-md p-6 mb-6 border border-border">
            <h2 class="text-xl font-semibold mb-4">3. Crop &amp; Download</h2>
            <button id="cropBtn" class="bg-primary text-primary-foreground px-4 py-2 rounded-md hover:bg-primary/90 transition-colors w-full">Crop and Download Selected Chunk</button>
        </div>
        
        <div id="statusMessage" class="mt-4 text-center text-muted-foreground">
            Load a CSV file to begin.
        </div>
    </div>

    <script>
        // JavaScript code will go here
        let imuChart = null;
        let originalData = [];
        let originalHeaders = ''; // To store the header line
        
        document.getElementById('csvFile').addEventListener('change', handleFileLoad);
        document.getElementById('cropBtn').addEventListener('click', handleCropAndDownload);
        
        function updateStatus(message, isError = false) {
            const statusEl = document.getElementById('statusMessage');
            statusEl.textContent = message;
            statusEl.className = `mt-4 text-center ${isError ? 'text-destructive' : 'text-muted-foreground'}`;
        }

        function handleFileLoad(event) {
            const file = event.target.files[0];
            if (!file) {
                updateStatus('No file selected.', true);
                return;
            }

            const reader = new FileReader();
            reader.onload = function(e) {
                const text = e.target.result;
                parseCSV(text);
            };
            reader.onerror = function() {
                updateStatus('Error reading file.', true);
            }
            reader.readAsText(file);
            updateStatus('Loading file...');
        }

        function parseCSV(csvText) {
            originalData = [];
            const lines = csvText.trim().split('\n');
            
            if (lines.length === 0) {
                updateStatus('CSV file is empty.', true);
                return;
            }

            // Attempt to find the header row
            let dataStartIndex = 0;
            for (let i = 0; i < lines.length; i++) {
                const line = lines[i].trim();
                // Heuristic: header is often the first line that contains common keywords
                // and doesn't look like metadata comments
                if (line.toLowerCase().includes('timestamp') || line.toLowerCase().includes('acc_x')) {
                    if (!line.startsWith('*') && !line.startsWith('-') && !line.startsWith('RECORDING')) {
                        originalHeaders = line;
                        dataStartIndex = i + 1;
                        break;
                    }
                }
                 if (i === 0 && !originalHeaders) { // Fallback if no clear header found, assume first line is header
                    originalHeaders = line;
                    dataStartIndex = 1;
                }
            }
            
            if (!originalHeaders && lines.length > 0) { // If still no header, assume first line might be it or no header
                 originalHeaders = lines[0].trim(); // Take the first line as potential header
                 dataStartIndex = lines[0].trim().split(',').every(val => !isNaN(parseFloat(val))) ? 0 : 1; // If first line is all numbers, assume no header
                 if (dataStartIndex === 0) originalHeaders = ''; // No header if first line is data
            }


            let currentTime = 0;
            let lastEpochTimestamp = 0;

            for (let i = dataStartIndex; i < lines.length; i++) {
                const line = lines[i].trim();
                if (!line || line.startsWith('*') || line.startsWith('-') || line.startsWith('RECORDING')) continue;

                const values = line.split(',');
                let record = { raw: line, values: values };
                
                // Determine timestamp for this record
                // This logic needs to be robust, similar to gesture_visualizer
                if (originalHeaders.includes('timestamp') && originalHeaders.includes('milliseconds')) {
                    const tsIndex = originalHeaders.split(',').indexOf('timestamp');
                    const msIndex = originalHeaders.split(',').indexOf('milliseconds');
                    if (tsIndex !== -1 && msIndex !== -1 && values.length > Math.max(tsIndex, msIndex)) {
                        const epochSec = parseFloat(values[tsIndex]);
                        const epochMs = parseFloat(values[msIndex]);
                        // Assume 'timestamp' is seconds and 'milliseconds' is the sub-second part within that second,
                        // or 'milliseconds' could be an independent running total.
                        // For simplicity, let's assume 'milliseconds' is the primary relative time if available and increasing.
                        // A more robust way would be to check if `timestamp` changes. If it's constant, `milliseconds` is the relative time.
                        // If `timestamp` increases, it's epoch time.
                        if (lastEpochTimestamp !== epochSec && epochSec > 1000000) { // Heuristic for epoch seconds
                            lastEpochTimestamp = epochSec;
                            currentTime = epochSec * 1000 + epochMs;
                        } else { // milliseconds is likely the running total
                             currentTime = epochMs; // Or handle as relative to a start if timestamp is 0 or constant
                        }
                         record.time = currentTime;
                    }
                } else if (originalHeaders.includes('rel_timestamp')) {
                    const relTsIndex = originalHeaders.split(',').indexOf('rel_timestamp');
                    if (relTsIndex !== -1 && values.length > relTsIndex) {
                        record.time = parseFloat(values[relTsIndex]);
                    }
                } else if (originalHeaders.includes('timestamp')) { // Older format
                    const tsIndex = originalHeaders.split(',').indexOf('timestamp');
                     if (tsIndex !== -1 && values.length > tsIndex) {
                        record.time = parseFloat(values[tsIndex]);
                    }
                } else { // No explicit time column found, try first column
                    if (values.length > 0 && !isNaN(parseFloat(values[0]))) {
                        record.time = parseFloat(values[0]);
                         if(!originalHeaders && i === dataStartIndex) { // If no header and first column is numeric, assume it's time
                            originalHeaders = "time,data1,data2,data3,data4,data5,data6,data7,data8,data9,data10".split(',').slice(0, values.length).join(',');
                        }
                    } else {
                        record.time = i * 10; // Fallback: assign arbitrary time based on line number (e.g., 10ms interval)
                        if(!originalHeaders && i === dataStartIndex) {
                            originalHeaders = "data1,data2,data3,data4,data5,data6,data7,data8,data9,data10".split(',').slice(0, values.length).join(',');
                        }
                    }
                }
                
                // Try to get accX, accY, accZ for plotting
                const headerCols = originalHeaders.toLowerCase().split(',');
                const accXIndex = headerCols.indexOf('acc_x');
                const accYIndex = headerCols.indexOf('acc_y');
                const accZIndex = headerCols.indexOf('acc_z');

                if (accXIndex !== -1) record.accX = parseFloat(values[accXIndex]);
                if (accYIndex !== -1) record.accY = parseFloat(values[accYIndex]);
                if (accZIndex !== -1) record.accZ = parseFloat(values[accZIndex]);

                // Try to get gyroX, gyroY, gyroZ for plotting
                const gyroXIndex = headerCols.indexOf('gyro_x');
                const gyroYIndex = headerCols.indexOf('gyro_y');
                const gyroZIndex = headerCols.indexOf('gyro_z');

                if (gyroXIndex !== -1) record.gyroX = parseFloat(values[gyroXIndex]);
                if (gyroYIndex !== -1) record.gyroY = parseFloat(values[gyroYIndex]);
                if (gyroZIndex !== -1) record.gyroZ = parseFloat(values[gyroZIndex]);

                originalData.push(record);
            }

            if (originalData.length === 0) {
                updateStatus('No data rows found in CSV or failed to parse time.', true);
                return;
            }
            
            // Normalize time if it's not starting near zero for some formats
            if (originalData.length > 0 && originalData[0].time > 1000000) { // Heuristic for large epoch timestamps
                const startTime = originalData[0].time;
                originalData.forEach(d => d.time -= startTime);
            }


            updateStatus(`Loaded ${originalData.length} data points. Header: ${originalHeaders || 'Not identified'}`);
            renderChart();
        }

        function renderChart() {
            if (imuChart) {
                imuChart.destroy();
            }
            
            const ctx = document.getElementById('imuChart').getContext('2d');
            
            const labels = originalData.map(d => d.time);
            const datasets = [];

            if (originalData.length > 0 && originalData[0].hasOwnProperty('accX')) {
                datasets.push({
                    label: 'Acc X',
                    data: originalData.map(d => d.accX),
                    borderColor: 'rgb(255, 99, 132)',
                    tension: 0.1,
                    pointRadius: 1,
                    borderWidth: 1,
                    yAxisID: 'yAcc'
                });
            }
            if (originalData.length > 0 && originalData[0].hasOwnProperty('accY')) {
                datasets.push({
                    label: 'Acc Y',
                    data: originalData.map(d => d.accY),
                    borderColor: 'rgb(54, 162, 235)',
                    tension: 0.1,
                    pointRadius: 1,
                    borderWidth: 1,
                    yAxisID: 'yAcc'
                });
            }
            if (originalData.length > 0 && originalData[0].hasOwnProperty('accZ')) {
                 datasets.push({
                    label: 'Acc Z',
                    data: originalData.map(d => d.accZ),
                    borderColor: 'rgb(75, 192, 192)',
                    tension: 0.1,
                    pointRadius: 1,
                    borderWidth: 1,
                    yAxisID: 'yAcc'
                });
            }

            // Add Gyroscope data if available
            if (originalData.length > 0 && originalData[0].hasOwnProperty('gyroX')) {
                datasets.push({
                    label: 'Gyro X',
                    data: originalData.map(d => d.gyroX),
                    borderColor: 'rgb(255, 159, 64)', // Orange
                    tension: 0.1,
                    pointRadius: 1,
                    borderWidth: 1,
                    yAxisID: 'yGyro'
                });
            }
            if (originalData.length > 0 && originalData[0].hasOwnProperty('gyroY')) {
                datasets.push({
                    label: 'Gyro Y',
                    data: originalData.map(d => d.gyroY),
                    borderColor: 'rgb(153, 102, 255)', // Purple
                    tension: 0.1,
                    pointRadius: 1,
                    borderWidth: 1,
                    yAxisID: 'yGyro'
                });
            }
            if (originalData.length > 0 && originalData[0].hasOwnProperty('gyroZ')) {
                 datasets.push({
                    label: 'Gyro Z',
                    data: originalData.map(d => d.gyroZ),
                    borderColor: 'rgb(255, 205, 86)', // Yellow
                    tension: 0.1,
                    pointRadius: 1,
                    borderWidth: 1,
                    yAxisID: 'yGyro'
                });
            }

            if (datasets.length === 0) { // Fallback: plot first few numeric columns if no acc_x/y/z or gyro_x/y/z
                const numCols = originalData[0] ? originalData[0].values.length : 0;
                const potentialDataCols = Math.min(numCols, 3); // Plot up to 3 fallback columns
                for (let i = 0; i < potentialDataCols; i++) {
                    // Check if column i (after potential time column) is numeric
                    const isNumeric = originalData.every(d => d.values[i] !== undefined && !isNaN(parseFloat(d.values[i])));
                    if (isNumeric) {
                        datasets.push({
                            label: `Column ${i+1}`,
                            data: originalData.map(d => parseFloat(d.values[i])),
                            borderColor: [`rgb(255, 99, 132)`, `rgb(54, 162, 235)`, `rgb(75, 192, 192)`][i % 3],
                            tension: 0.1,
                            pointRadius: 1,
                            borderWidth: 1
                        });
                    }
                }
            }
            
            if (datasets.length === 0) {
                updateStatus('No plottable data columns (AccX/Y/Z, GyroX/Y/Z or numeric) found in CSV.', true);
                return;
            }

            // Register the annotation plugin
            
            imuChart = new Chart(ctx, {
                type: 'line',
                data: {
                    labels: labels,
                    datasets: datasets
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    scales: {
                        x: {
                            title: { display: true, text: 'Time (ms)' }
                        },
                        yAcc: {
                            type: 'linear',
                            display: true,
                            position: 'left',
                            title: { display: true, text: 'Accelerometer Value' }
                        },
                        yGyro: {
                            type: 'linear',
                            display: true,
                            position: 'right',
                            title: { display: true, text: 'Gyroscope Value' },
                            grid: {
                                drawOnChartArea: false,
                            }
                        }
                    },
                    onClick: (event, elements) => {
                        // Remove old onClick logic, slider handles selection now
                        if (elements.length > 0) {
                            const chartElement = elements[0];
                            const dataPoint = originalData[chartElement.index];
                            if (dataPoint && dataPoint.time !== undefined) {
                                document.getElementById('startTime').value = Math.round(dataPoint.time);
                                updateStatus(`Selected start time: ${Math.round(dataPoint.time)} ms`);
                            }
                        }
                    },
                    plugins: {
                        tooltip: {
                            callbacks: {
                                title: function(tooltipItems) {
                                    if (tooltipItems.length > 0) {
                                        const dataIndex = tooltipItems[0].dataIndex;
                                        return `Time: ${originalData[dataIndex].time.toFixed(2)} ms`;
                                    }
                                    return '';
                                }
                            }
                        },
                        
                    }
                }
            });

            // Initialize noUiSlider
            
            // Update chart annotation and display fields when slider changes
            
            // Set initial annotation box based on slider
            
        }

        function handleCropAndDownload() {
            if (originalData.length === 0) {
                updateStatus('No data loaded or slider not initialized.', true);
                return;
            }

            
            const startTime = parseFloat(document.getElementById('startTime').value);
            const duration = parseFloat(document.getElementById('chunkDuration').value);

            if (isNaN(startTime) || isNaN(duration) || duration <= 0) {
                updateStatus('Invalid start time or duration.', true);
                return;
            }

            const croppedData = originalData.filter(d => d.time >= startTime && d.time < startTime + duration);

            if (croppedData.length === 0) {
                updateStatus('No data points found in the selected time range.', true);
                return;
            }

            // Create CSV content
            let csvContent = "";
            if (originalHeaders) {
                csvContent += originalHeaders + '\n';
            }
            
            croppedData.forEach(row => {
                csvContent += row.raw + '\n';
            });

            // Create a blob and trigger download
            const blob = new Blob([csvContent], { type: 'text/csv;charset=utf-8;' });
            const link = document.createElement("a");
            if (link.download !== undefined) { // Feature detection
                const url = URL.createObjectURL(blob);
                link.setAttribute("href", url);
                link.setAttribute("download", `cropped_imu_data_${startTime}ms_${duration}ms.csv`);
                link.style.visibility = 'hidden';
                document.body.appendChild(link);
                link.click();
                document.body.removeChild(link);
                updateStatus(`Successfully downloaded ${croppedData.length} cropped data points.`);
            } else {
                updateStatus('CSV download not supported by your browser.', true);
            }
        }

    </script>
</body>
</html> 